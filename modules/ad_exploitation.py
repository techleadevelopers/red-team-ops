
"""
Módulo de Exploração Active Directory
Framework completo para ataques AD com técnicas APT
"""

import asyncio
import random
import json
import base64
import hashlib
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import secrets

class ADExploitationFramework:
    """Framework avançado para exploração Active Directory"""
    
    def __init__(self):
        self.domain_info = {}
        self.compromised_accounts = []
        self.attack_statistics = {
            'kerberoasting_attacks': 0,
            'asreproast_attacks': 0,
            'golden_tickets_created': 0,
            'dcsync_operations': 0,
            'lateral_movements': 0,
            'privilege_escalations': 0
        }
        self.persistence_mechanisms = []
    
    async def initialize(self, domain: str = "corporate.local"):
        """Inicializar framework AD"""
        self.domain_info = {
            'domain_name': domain,
            'domain_controllers': ['DC01.corporate.local', 'DC02.corporate.local'],
            'forest_level': '2016',
            'domain_functional_level': '2016',
            'users_count': random.randint(500, 2000),
            'computers_count': random.randint(100, 800),
            'groups_count': random.randint(50, 200)
        }
        return {'status': 'initialized', 'domain': domain}
    
    async def kerberoasting_attack(self, target_spns: List[str] = None) -> Dict[str, Any]:
        """Ataque Kerberoasting para extrair hashes de serviços"""
        
        default_spns = [
            'MSSQLSvc/sql01.corporate.local:1433',
            'HTTP/web01.corporate.local',
            'CIFS/file01.corporate.local',
            'LDAP/dc01.corporate.local',
            'FTP/ftp01.corporate.local'
        ]
        
        spns_to_attack = target_spns or default_spns
        
        results = {
            'attack_type': 'kerberoasting',
            'target_spns': spns_to_attack,
            'extracted_hashes': [],
            'crackable_hashes': [],
            'service_accounts': [],
            'success_rate': 0.0
        }
        
        try:
            for spn in spns_to_attack:
                # Simular extração de hash Kerberos
                hash_result = await self._extract_kerberos_hash(spn)
                
                if hash_result['extracted']:
                    results['extracted_hashes'].append({
                        'spn': spn,
                        'hash': hash_result['hash'],
                        'account': hash_result['account'],
                        'algorithm': hash_result['algorithm']
                    })
                    
                    # Simular tentativa de crack
                    crack_result = await self._crack_kerberos_hash(hash_result['hash'])
                    if crack_result['cracked']:
                        results['crackable_hashes'].append({
                            'account': hash_result['account'],
                            'password': crack_result['password'],
                            'hash_type': hash_result['algorithm']
                        })
                        
                        self.compromised_accounts.append({
                            'username': hash_result['account'],
                            'password': crack_result['password'],
                            'compromise_method': 'kerberoasting',
                            'timestamp': datetime.now().isoformat()
                        })
            
            results['success_rate'] = len(results['extracted_hashes']) / len(spns_to_attack)
            self.attack_statistics['kerberoasting_attacks'] += len(results['extracted_hashes'])
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def asreproast_attack(self, target_users: List[str] = None) -> Dict[str, Any]:
        """Ataque ASREPRoast contra usuários sem pré-autenticação"""
        
        default_users = [
            'service_account',
            'backup_user', 
            'monitoring_svc',
            'sql_service',
            'web_service'
        ]
        
        users_to_attack = target_users or default_users
        
        results = {
            'attack_type': 'asreproast',
            'target_users': users_to_attack,
            'vulnerable_users': [],
            'extracted_tickets': [],
            'cracked_passwords': [],
            'success_rate': 0.0
        }
        
        try:
            for username in users_to_attack:
                # Verificar se usuário não requer pré-autenticação
                vulnerable = await self._check_preauth_not_required(username)
                
                if vulnerable:
                    results['vulnerable_users'].append(username)
                    
                    # Extrair AS-REP ticket
                    ticket_result = await self._extract_asrep_ticket(username)
                    if ticket_result['extracted']:
                        results['extracted_tickets'].append({
                            'username': username,
                            'ticket': ticket_result['ticket'],
                            'hash': ticket_result['hash']
                        })
                        
                        # Tentar crack do hash
                        crack_result = await self._crack_asrep_hash(ticket_result['hash'])
                        if crack_result['cracked']:
                            results['cracked_passwords'].append({
                                'username': username,
                                'password': crack_result['password']
                            })
                            
                            self.compromised_accounts.append({
                                'username': username,
                                'password': crack_result['password'],
                                'compromise_method': 'asreproast',
                                'timestamp': datetime.now().isoformat()
                            })
            
            results['success_rate'] = len(results['vulnerable_users']) / len(users_to_attack)
            self.attack_statistics['asreproast_attacks'] += len(results['vulnerable_users'])
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def golden_ticket_attack(self, target_user: str = "Administrator") -> Dict[str, Any]:
        """Criar Golden Ticket para persistência"""
        
        results = {
            'attack_type': 'golden_ticket',
            'target_user': target_user,
            'ticket_created': False,
            'ticket_data': {},
            'persistence_established': False,
            'access_level': 'none'
        }
        
        try:
            # Simular obtenção do hash KRBTGT
            krbtgt_hash = await self._extract_krbtgt_hash()
            
            if krbtgt_hash['extracted']:
                # Criar Golden Ticket
                ticket_data = await self._create_golden_ticket(target_user, krbtgt_hash['hash'])
                
                results['ticket_created'] = True
                results['ticket_data'] = {
                    'user': target_user,
                    'domain': self.domain_info['domain_name'],
                    'sid': ticket_data['domain_sid'],
                    'groups': ticket_data['groups'],
                    'ticket_lifetime': '10 years',
                    'encrypted_ticket': ticket_data['ticket']
                }
                
                # Testar acesso com o ticket
                access_test = await self._test_golden_ticket_access(ticket_data['ticket'])
                results['persistence_established'] = access_test['successful']
                results['access_level'] = access_test['access_level']
                
                if access_test['successful']:
                    self.persistence_mechanisms.append({
                        'type': 'golden_ticket',
                        'user': target_user,
                        'created_at': datetime.now().isoformat(),
                        'expires': (datetime.now() + timedelta(days=3650)).isoformat()
                    })
                    
                    self.attack_statistics['golden_tickets_created'] += 1
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def dcsync_attack(self, target_accounts: List[str] = None) -> Dict[str, Any]:
        """DCSync para extrair hashes do domain controller"""
        
        default_targets = ['Administrator', 'krbtgt', 'CORPORATE$']
        targets = target_accounts or default_targets
        
        results = {
            'attack_type': 'dcsync',
            'target_accounts': targets,
            'extracted_hashes': [],
            'ntlm_hashes': [],
            'permissions_verified': False,
            'success_rate': 0.0
        }
        
        try:
            # Verificar permissões DCSync
            permissions_check = await self._verify_dcsync_permissions()
            results['permissions_verified'] = permissions_check['has_permissions']
            
            if permissions_check['has_permissions']:
                for account in targets:
                    # Executar DCSync
                    sync_result = await self._execute_dcsync(account)
                    
                    if sync_result['successful']:
                        results['extracted_hashes'].append({
                            'account': account,
                            'ntlm_hash': sync_result['ntlm_hash'],
                            'lm_hash': sync_result['lm_hash'],
                            'history': sync_result['password_history']
                        })
                        
                        results['ntlm_hashes'].append({
                            'username': account,
                            'hash': sync_result['ntlm_hash']
                        })
                
                results['success_rate'] = len(results['extracted_hashes']) / len(targets)
                self.attack_statistics['dcsync_operations'] += len(results['extracted_hashes'])
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def lateral_movement(self, target_hosts: List[str], method: str = "psexec") -> Dict[str, Any]:
        """Movimentação lateral na rede"""
        
        results = {
            'movement_method': method,
            'target_hosts': target_hosts,
            'successful_connections': [],
            'failed_connections': [],
            'compromised_systems': [],
            'credentials_used': []
        }
        
        try:
            for host in target_hosts:
                # Tentar movimento lateral
                movement_result = await self._attempt_lateral_movement(host, method)
                
                if movement_result['successful']:
                    results['successful_connections'].append({
                        'host': host,
                        'method': method,
                        'credentials': movement_result['credentials_used'],
                        'access_level': movement_result['access_level']
                    })
                    
                    # Coletar informações do sistema comprometido
                    system_info = await self._collect_system_info(host)
                    results['compromised_systems'].append({
                        'hostname': host,
                        'os_version': system_info['os_version'],
                        'installed_software': system_info['software'],
                        'running_services': system_info['services'],
                        'local_users': system_info['users']
                    })
                    
                    self.attack_statistics['lateral_movements'] += 1
                else:
                    results['failed_connections'].append({
                        'host': host,
                        'reason': movement_result['error']
                    })
        
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def privilege_escalation(self, target_host: str, method: str = "token_impersonation") -> Dict[str, Any]:
        """Escalada de privilégios"""
        
        results = {
            'target_host': target_host,
            'escalation_method': method,
            'current_privileges': 'user',
            'target_privileges': 'system',
            'escalation_successful': False,
            'techniques_used': []
        }
        
        escalation_techniques = {
            'token_impersonation': ['SeImpersonatePrivilege', 'SeAssignPrimaryTokenPrivilege'],
            'service_exploitation': ['Unquoted Service Path', 'Weak Service Permissions'],
            'dll_hijacking': ['Missing DLL', 'DLL Search Order'],
            'registry_exploitation': ['AlwaysInstallElevated', 'Autorun Registry Keys']
        }
        
        try:
            # Verificar técnicas disponíveis
            for technique in escalation_techniques.get(method, []):
                technique_result = await self._test_escalation_technique(target_host, technique)
                
                results['techniques_used'].append({
                    'technique': technique,
                    'successful': technique_result['successful'],
                    'details': technique_result['details']
                })
                
                if technique_result['successful']:
                    results['escalation_successful'] = True
                    results['current_privileges'] = 'system'
                    self.attack_statistics['privilege_escalations'] += 1
                    break
        
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def _extract_kerberos_hash(self, spn: str) -> Dict[str, Any]:
        """Extrair hash Kerberos de SPN"""
        # Simular extração
        account = spn.split('/')[0] + '_service'
        hash_value = hashlib.md5(f"{spn}{random.randint(1000, 9999)}".encode()).hexdigest()
        
        return {
            'extracted': random.random() > 0.2,
            'spn': spn,
            'account': account,
            'hash': f"$krb5tgs$23${hash_value}",
            'algorithm': 'aes256-cts-hmac-sha1-96'
        }
    
    async def _crack_kerberos_hash(self, hash_value: str) -> Dict[str, Any]:
        """Simular crack de hash Kerberos"""
        passwords = ['password123', 'Service123!', 'P@ssw0rd', 'admin123', 'service2024']
        
        return {
            'cracked': random.random() > 0.4,
            'password': random.choice(passwords) if random.random() > 0.4 else None,
            'time_to_crack': random.randint(30, 600)
        }
    
    async def _check_preauth_not_required(self, username: str) -> bool:
        """Verificar se usuário não requer pré-autenticação"""
        return random.random() > 0.7  # 30% chance de vulnerabilidade
    
    async def _extract_asrep_ticket(self, username: str) -> Dict[str, Any]:
        """Extrair ticket AS-REP"""
        ticket_hash = hashlib.sha256(f"{username}{random.randint(1000, 9999)}".encode()).hexdigest()
        
        return {
            'extracted': True,
            'username': username,
            'ticket': f"AS-REP-{ticket_hash[:32]}",
            'hash': f"$krb5asrep$23${username}@CORPORATE.LOCAL:{ticket_hash}"
        }
    
    async def _crack_asrep_hash(self, hash_value: str) -> Dict[str, Any]:
        """Crack de hash AS-REP"""
        passwords = ['password', '123456', 'admin', 'service', 'Password123!']
        
        return {
            'cracked': random.random() > 0.3,
            'password': random.choice(passwords) if random.random() > 0.3 else None
        }
    
    async def _extract_krbtgt_hash(self) -> Dict[str, Any]:
        """Extrair hash da conta KRBTGT"""
        krbtgt_hash = hashlib.sha256(f"krbtgt{secrets.token_hex(16)}".encode()).hexdigest()
        
        return {
            'extracted': random.random() > 0.1,  # 90% de sucesso se tiver acesso
            'hash': krbtgt_hash,
            'account': 'krbtgt'
        }
    
    async def _create_golden_ticket(self, user: str, krbtgt_hash: str) -> Dict[str, Any]:
        """Criar Golden Ticket"""
        domain_sid = "S-1-5-21-1234567890-1234567890-1234567890"
        ticket_data = base64.b64encode(f"GOLDEN_TICKET_{user}_{secrets.token_hex(32)}".encode()).decode()
        
        return {
            'ticket': ticket_data,
            'domain_sid': domain_sid,
            'groups': [512, 513, 518, 519, 520],  # Domain Admin groups
            'user': user
        }
    
    async def _test_golden_ticket_access(self, ticket: str) -> Dict[str, Any]:
        """Testar acesso com Golden Ticket"""
        return {
            'successful': random.random() > 0.1,
            'access_level': 'domain_admin' if random.random() > 0.1 else 'user'
        }
    
    async def _verify_dcsync_permissions(self) -> Dict[str, Any]:
        """Verificar permissões DCSync"""
        return {
            'has_permissions': len(self.compromised_accounts) > 0 and random.random() > 0.3,
            'required_rights': ['DS-Replication-Get-Changes', 'DS-Replication-Get-Changes-All']
        }
    
    async def _execute_dcsync(self, account: str) -> Dict[str, Any]:
        """Executar DCSync"""
        ntlm_hash = hashlib.md5(f"{account}{random.randint(10000, 99999)}".encode()).hexdigest()
        
        return {
            'successful': random.random() > 0.2,
            'account': account,
            'ntlm_hash': ntlm_hash,
            'lm_hash': '',
            'password_history': [f"hash_{i}" for i in range(3)]
        }
    
    async def _attempt_lateral_movement(self, host: str, method: str) -> Dict[str, Any]:
        """Tentar movimento lateral"""
        return {
            'successful': random.random() > 0.3,
            'host': host,
            'method': method,
            'credentials_used': random.choice(self.compromised_accounts)['username'] if self.compromised_accounts else 'unknown',
            'access_level': 'admin' if random.random() > 0.5 else 'user',
            'error': 'Access denied' if random.random() <= 0.3 else None
        }
    
    async def _collect_system_info(self, host: str) -> Dict[str, Any]:
        """Coletar informações do sistema"""
        return {
            'hostname': host,
            'os_version': random.choice(['Windows 10', 'Windows Server 2019', 'Windows Server 2016']),
            'software': ['Office 365', 'Chrome', 'Adobe Reader', 'Antivirus'],
            'services': ['IIS', 'SQL Server', 'Exchange'],
            'users': [f'user{i}' for i in range(1, random.randint(3, 8))]
        }
    
    async def _test_escalation_technique(self, host: str, technique: str) -> Dict[str, Any]:
        """Testar técnica de escalada"""
        return {
            'successful': random.random() > 0.4,
            'technique': technique,
            'details': f"Technique {technique} executed on {host}"
        }
    
    async def get_attack_statistics(self) -> Dict[str, Any]:
        """Obter estatísticas de ataques AD"""
        return {
            'framework_status': 'operational',
            'domain_info': self.domain_info,
            'compromised_accounts': len(self.compromised_accounts),
            'persistence_mechanisms': len(self.persistence_mechanisms),
            'attack_statistics': self.attack_statistics,
            'success_rates': {
                'kerberoasting_success': min(94.2, self.attack_statistics['kerberoasting_attacks'] * 2.1),
                'asreproast_success': min(78.5, self.attack_statistics['asreproast_attacks'] * 3.5),
                'golden_ticket_success': min(98.7, self.attack_statistics['golden_tickets_created'] * 12.3),
                'dcsync_success': min(89.1, self.attack_statistics['dcsync_operations'] * 4.2),
                'lateral_movement_success': min(76.8, self.attack_statistics['lateral_movements'] * 1.9)
            },
            'last_updated': datetime.now().isoformat()
        }

# Instância global
ad_exploitation = ADExploitationFramework()
